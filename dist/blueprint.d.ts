/// <reference types="yargs" />
import * as yargs from 'yargs';
import Command from './command';
/**
 * The Blueprint class manages generating code from a template, or "blueprint". Blueprints have
 * three main parts:
 *
 * - The `locals()` hook, used to generate data to fill in the the templates
 *
 * - Templates, found under `<blueprint dir>/files`. These files are copied over into the project.
 *   The can contain ERB style interpolation to inject values from the `locals` data. Filenames can
 *   also contain variables, delimited by `__variable__`
 *
 * - The `postInstall()` hook, which runs after the copying operation is finished. This gives the
 *   blueprint a chance to perform additional steps that simple templating can't support (i.e.
 *   install an node module).
 *
 * The code generated by a blueprint can also be removed via the `destroy` command. That command
 * will only remove files that exactly match the what the blueprint generates, so if you modify a
 * file after it was generated, it won't be removed.
 *
 * @module denali-cli
 */
export default class Blueprint extends Command {
    /**
     * Convenience method for calling `.findBlueprints()` and then `.configureBlueprints()`
     */
    static findAndConfigureBlueprints(yargs: yargs.Argv, action: 'generate' | 'destroy', projectPkg: any): yargs.Argv;
    /**
     * Find all available blueprints
     */
    static findBlueprints(projectPkg: any): {
        [name: string]: typeof Blueprint;
    };
    /**
     * Given a set of blueprints and a yargs instance, given each blueprint the chance to add a
     * command to the yargs instance for itself
     */
    static configureBlueprints(blueprints: {
        [name: string]: typeof Blueprint;
    }, yargs: yargs.Argv, action: 'generate' | 'destroy', projectPkg: any): yargs.Argv;
    /**
     * Given an addon's name and source directory, load all the blueprints that addon may supply
     */
    static discoverBlueprintsForAddon(blueprintsSoFar: {
        [blueprintName: string]: typeof Blueprint;
    }, addonName: string, dir: string): {};
    /**
     * Customize the subcommands header to indicate that it's a list of blueprints
     */
    static configure(blueprintName: string, yargs: yargs.Argv, projectPkg: any, action: 'generate' | 'destroy'): yargs.Argv;
    /**
     * The name used to invoke this blueprint.
     */
    static blueprintName: string;
    /**
     * The source directory for this blueprints
     */
    static dir: string;
    /**
     * Files that should be renamed in all blueprints
     * Can be overriden/extended by individual addons
     */
    static renamedFiles: any;
    /**
     * Should we generate or destroy this blueprint?
     */
    action: 'generate' | 'destroy';
    /**
     * Immediately delegates to either generate or destroy
     */
    run(argv: any): Promise<void>;
    /**
     * Generate the blueprint. Generates the data to interpolate into the templates, then copies the
     * template files over into the project. Finally, runs the postInstall hook.
     */
    generate(argv: any): Promise<void>;
    /**
     * Destroy the blueprint. Generates the data to interpolate into the templates, then deletes any
     * unmodified files that were generated by this blueprint. Then runs the postUninstall hook.
     */
    destroy(argv: any): Promise<void>;
    /**
     * A hook to generate data to be interpolated into the blueprint's template files.
     */
    locals(argv: any): any;
    /**
     * Runs after the templating step is complete, letting you make additional modifications (i.e.
     * install a node module).
     */
    postInstall(argv: any): Promise<void>;
    /**
     * Runs when `denali destroy` is invoked, after the applicable template files have been removed.
     * You should clean up / reverse any changes made in postInstall(), but only in a way that avoids
     * removing user modifications.
     */
    postUninstall(argv: any): Promise<void>;
    /**
     * Returns the path to this blueprints template files directory. Defaults to `files/`.
     */
    readonly templateFiles: string;
    /**
     * Adds a route to this package's router.
     */
    addRoute(method: string, urlPattern: string, actionPath?: string, ...args: any[]): void;
    /**
     * Removes a route from this package's router
     */
    removeRoute(method: string, urlPattern: string, actionPath?: string, ...args: any[]): void;
    /**
     * Add a package to this project, using yarn or npm as appropriate.
     */
    installPackage(pkgName: string, dev?: boolean): void;
    /**
     * Add multiple packages to this project, using yarn or npm as appropriate.
     */
    installPackages(pkgNames: string[], dev?: boolean): void;
    /**
     * Remove a package from this project, using yarn or npm as appropriate.
     */
    uninstallPackage(pkgName: string): void;
    /**
     * Remove multiple packages from this project, using yarn or npm as appropriate.
     */
    uninstallPackages(pkgNames: string[]): void;
    /**
     * Check to see whether this project is using yarn for package management
     */
    shouldUseYarn(): boolean;
}
