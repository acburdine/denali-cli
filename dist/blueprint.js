"use strict";
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const path = require("path");
const fs = require("fs");
const child_process_1 = require("child_process");
const command_exists_1 = require("command-exists");
const assert = require("assert");
const chalk = require("chalk");
const walk = require("walk-sync");
const codeshift = require("jscodeshift");
const mkdirp = require("mkdirp");
const rimraf = require("rimraf");
const is_directory_1 = require("is-directory");
const ui_1 = require("./ui");
const find_addons_1 = require("./find-addons");
const command_1 = require("./command");
const createDebug = require("debug");
const tryRequire = require("try-require");
const debug = createDebug('denali-cli:blueprint');
/**
 * The Blueprint class manages generating code from a template, or "blueprint". Blueprints have
 * three main parts:
 *
 * - The `locals()` hook, used to generate data to fill in the the templates
 *
 * - Templates, found under `<blueprint dir>/files`. These files are copied over into the project.
 *   The can contain ERB style interpolation to inject values from the `locals` data. Filenames can
 *   also contain variables, delimited by `__variable__`
 *
 * - The `postInstall()` hook, which runs after the copying operation is finished. This gives the
 *   blueprint a chance to perform additional steps that simple templating can't support (i.e.
 *   install an node module).
 *
 * The code generated by a blueprint can also be removed via the `destroy` command. That command
 * will only remove files that exactly match the what the blueprint generates, so if you modify a
 * file after it was generated, it won't be removed.
 *
 * @module denali-cli
 */
class Blueprint extends command_1.default {
    /**
     * Convenience method for calling `.findBlueprints()` and then `.configureBlueprints()`
     */
    static findAndConfigureBlueprints(yargs, action, projectPkg) {
        let blueprints = this.findBlueprints(projectPkg);
        return this.configureBlueprints(blueprints, yargs, action, projectPkg);
    }
    /**
     * Find all available blueprints
     */
    static findBlueprints(projectPkg) {
        let blueprints = {};
        // Special case denali itself, so it can access it's globally linked blueprints.
        let addons = find_addons_1.default(projectPkg && projectPkg.name !== 'denali');
        debug(`discovering available blueprints from [ ${addons.map((a) => a.pkg.name).join(', ')} ] addons`);
        addons.forEach((addon) => {
            this.discoverBlueprintsForAddon(blueprints, addon.pkg.name, path.join(addon.dir, 'blueprints'));
        });
        return blueprints;
    }
    /**
     * Given a set of blueprints and a yargs instance, given each blueprint the chance to add a
     * command to the yargs instance for itself
     */
    static configureBlueprints(blueprints, yargs, action, projectPkg) {
        // Configure a yargs instance with a command for each one
        lodash_1.forEach(blueprints, (BlueprintClass, name) => {
            try {
                debug(`configuring ${BlueprintClass.blueprintName} blueprint (invocation: "${name}")`);
                yargs = BlueprintClass.configure(name, yargs, projectPkg, action);
            }
            catch (error) {
                ui_1.default.warn(`${name} blueprint failed to configure itself:`);
                ui_1.default.warn(error.stack);
            }
        });
        return yargs;
    }
    /**
     * Given an addon's name and source directory, load all the blueprints that addon may supply
     */
    static discoverBlueprintsForAddon(blueprintsSoFar, addonName, dir) {
        debug(`looking for blueprints in ${dir}`);
        if (!fs.existsSync(dir)) {
            debug(`${dir} does not exist, skipping ...`);
            return {};
        }
        // Load the blueprints
        let Blueprints = fs.readdirSync(dir)
            .filter((dirname) => is_directory_1.sync(path.join(dir, dirname)))
            .reduce((BlueprintsSoFar, dirname) => {
            let BlueprintClass = tryRequire(path.join(dir, dirname));
            assert(BlueprintClass, `Unable to load blueprint from ${path.join(dir, dirname)}`);
            BlueprintClass.addon = addonName;
            BlueprintsSoFar[dirname] = BlueprintClass.default || BlueprintClass;
            return BlueprintsSoFar;
        }, {});
        // Capture the source directory of the blueprint
        lodash_1.forEach(Blueprints, (BlueprintClass, blueprintDir) => {
            BlueprintClass.dir = path.join(dir, blueprintDir);
        });
        // Then use the blueprintName as the invocation name, if provided (otherwise, fallback to the
        // directory name
        Blueprints = lodash_1.mapKeys(Blueprints, (BlueprintClass, blueprintDir) => BlueprintClass.blueprintName || blueprintDir);
        debug(`found ${lodash_1.keys(Blueprints).length} blueprints for ${addonName}: [ ${lodash_1.keys(Blueprints).join(', ')} ]`);
        // Move any already-loaded blueprints with the same name as these new ones under an addon-scoped
        // namespace
        lodash_1.intersection(lodash_1.keys(Blueprints), lodash_1.keys(blueprintsSoFar)).forEach((collidingBlueprintName) => {
            let clobberedBlueprint = blueprintsSoFar[collidingBlueprintName];
            blueprintsSoFar[clobberedBlueprint.addon + ':' + collidingBlueprintName] = clobberedBlueprint;
        });
        // Also create a map with the blueprint names scoped to the addon name
        return lodash_1.assign(blueprintsSoFar, Blueprints);
    }
    /**
     * Customize the subcommands header to indicate that it's a list of blueprints
     */
    static configure(blueprintName, yargs, projectPkg, action) {
        return super.configure(blueprintName, yargs, projectPkg, { action })
            .updateStrings({
            'Commands:': 'Available Blueprints:'
        });
    }
    /**
     * Immediately delegates to either generate or destroy
     */
    run(argv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (argv.action === 'generate') {
                yield this.generate(argv);
            }
            else {
                yield this.destroy(argv);
            }
        });
    }
    /**
     * Generate the blueprint. Generates the data to interpolate into the templates, then copies the
     * template files over into the project. Finally, runs the postInstall hook.
     */
    generate(argv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let data = this.locals(argv);
            let dest = process.cwd();
            let renamedFiles = this.constructor.renamedFiles;
            walk(this.templateFiles).forEach((relativepath) => {
                let absolutepath = path.resolve(path.join(this.templateFiles, relativepath));
                if (is_directory_1.sync(absolutepath)) {
                    return null;
                }
                let filenameTemplate = lodash_1.template(relativepath, {
                    interpolate: /__(.+?)__/g,
                    sourceURL: relativepath
                });
                let destRelativepath = filenameTemplate(data);
                let basename = path.basename(destRelativepath);
                if (renamedFiles[basename]) {
                    destRelativepath = path.join(path.dirname(destRelativepath), renamedFiles[basename]);
                }
                let destAbsolutepath = path.join(dest, destRelativepath);
                if (fs.existsSync(destAbsolutepath)) {
                    ui_1.default.info(`${chalk.green('already exists')} ${destRelativepath}`);
                    return;
                }
                let contents = fs.readFileSync(absolutepath, 'utf-8');
                let contentsTemplate = lodash_1.template(contents, {
                    interpolate: /<%=([\s\S]+?)%>/g,
                    sourceURL: relativepath
                });
                mkdirp.sync(path.dirname(destAbsolutepath));
                fs.writeFileSync(destAbsolutepath, contentsTemplate(data));
                ui_1.default.info(`${chalk.green('create')} ${destRelativepath}`);
            });
            if (!argv.skipPostInstall) {
                try {
                    yield this.postInstall(argv);
                }
                catch (e) {
                    ui_1.default.error('postInstall failed:');
                    ui_1.default.error(e.stack || e);
                }
            }
        });
    }
    /**
     * Destroy the blueprint. Generates the data to interpolate into the templates, then deletes any
     * unmodified files that were generated by this blueprint. Then runs the postUninstall hook.
     */
    destroy(argv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let data = this.locals(argv);
            let dest = process.cwd();
            let filesToDelete = [];
            walk(this.templateFiles).forEach((relativepath) => {
                return filesToDelete.push(path.resolve(path.join(this.templateFiles, relativepath)));
            });
            // Get the absolute paths for the template source file and the dest file
            filesToDelete = filesToDelete.map((absolutepath) => {
                let relativepath = path.relative(this.templateFiles, absolutepath);
                let filenameTemplate = lodash_1.template(relativepath, { interpolate: /__([\S]+)__/g });
                let destRelativepath = filenameTemplate(data);
                let destAbsolutepath = path.join(dest, destRelativepath);
                return { destAbsolutepath, destRelativepath, absolutepath };
                // Ensure that the dest file actually exists
            }).filter(({ destAbsolutepath, destRelativepath, absolutepath }) => {
                if (is_directory_1.sync(absolutepath)) {
                    return false;
                }
                let fileExists = fs.existsSync(destAbsolutepath);
                if (!fileExists) {
                    ui_1.default.info(`${chalk.grey('missing')} ${destRelativepath}`);
                }
                return fileExists;
                // And either hasn't been altered, or the force option is being used, to ensure we don't destroy
                // code
            }).filter(({ destAbsolutepath, absolutepath, destRelativepath }) => {
                let templateSrc = fs.readFileSync(absolutepath, 'utf-8');
                let compiled = lodash_1.template(templateSrc);
                let destFileIsNotDirty = fs.readFileSync(destAbsolutepath, 'utf-8') === compiled(data);
                if (destFileIsNotDirty) {
                    ui_1.default.info(`${chalk.red('destroy')} ${destRelativepath}`);
                }
                else {
                    ui_1.default.info(`${chalk.blue('skipped')} ${destRelativepath}`);
                }
                return destFileIsNotDirty;
            }).map(({ destAbsolutepath }) => {
                return destAbsolutepath;
            });
            filesToDelete.forEach((file) => {
                rimraf.sync(file);
            });
            if (!argv.skipPostUninstall) {
                try {
                    yield this.postUninstall(argv);
                }
                catch (e) {
                    ui_1.default.error('postInstall failed:');
                    ui_1.default.error(e.stack || e);
                }
            }
        });
    }
    /**
     * A hook to generate data to be interpolated into the blueprint's template files.
     */
    locals(argv) {
        return argv;
    }
    /**
     * Runs after the templating step is complete, letting you make additional modifications (i.e.
     * install a node module).
     */
    postInstall(argv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * Runs when `denali destroy` is invoked, after the applicable template files have been removed.
     * You should clean up / reverse any changes made in postInstall(), but only in a way that avoids
     * removing user modifications.
     */
    postUninstall(argv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
    }
    /**
     * Returns the path to this blueprints template files directory. Defaults to `files/`.
     */
    get templateFiles() {
        return path.join(this.constructor.dir, 'files');
    }
    /**
     * Adds a route to this package's router.
     */
    addRoute(method, urlPattern, actionPath, ...args) {
        let routesFilepath = path.join(process.cwd(), 'config', 'routes.js');
        let routesSource;
        try {
            routesSource = fs.readFileSync(routesFilepath, 'utf-8');
        }
        catch (e) {
            ui_1.default.warn(`Attempted to add "${method.toUpperCase()} ${urlPattern} -> ${actionPath}" route, but config/routes.js does not exist. Skipping ...`);
            return;
        }
        let j = codeshift;
        let ast = codeshift(routesSource);
        let drawRoutesFunction = ast.find(j.ExportDefaultDeclaration).get().value.declaration;
        let routerArgName = drawRoutesFunction.params[0].name;
        let drawRoutesFunctionBody = j(drawRoutesFunction.body);
        let duplicate = drawRoutesFunctionBody.find(j.ExpressionStatement, {
            expression: {
                callee: {
                    object: { name: routerArgName },
                    property: { name: method }
                },
                arguments: [urlPattern, actionPath].concat(args).map((arg) => {
                    return { value: arg };
                })
            }
        });
        if (duplicate.length > 0) {
            return;
        }
        let routerInvocations = drawRoutesFunctionBody.find(j.ExpressionStatement, {
            expression: {
                callee: {
                    object: { name: routerArgName }
                }
            }
        });
        let lastRouterInvocation = routerInvocations.at(routerInvocations.length - 1);
        let routerMethodExpression = j.memberExpression(j.identifier(routerArgName), j.identifier(method));
        let routerArguments = args.map((arg) => j.stringLiteral(arg));
        let routerMethodInvocation = j.callExpression(routerMethodExpression, routerArguments);
        let newRoute = j.expressionStatement(routerMethodInvocation);
        lastRouterInvocation.insertAfter(newRoute);
        fs.writeFileSync(routesFilepath, ast.toSource({ quote: 'single' }));
    }
    /**
     * Removes a route from this package's router
     */
    removeRoute(method, urlPattern, actionPath, ...args) {
        let routesFilepath = path.join(process.cwd(), 'config', 'routes.js');
        let routesSource;
        try {
            routesSource = fs.readFileSync(routesFilepath, 'utf-8');
        }
        catch (e) {
            ui_1.default.warn(`Attempted to remove "${method.toUpperCase()} ${urlPattern} -> ${actionPath}" route, but config/routes.js does not exist. Skipping ...`);
            return;
        }
        let j = codeshift;
        let ast = codeshift(routesSource);
        let drawRoutesFunction = ast.find(j.ExportDefaultDeclaration).get().value.declaration;
        let routerArgName = drawRoutesFunction.params[0].name;
        let drawRoutesFunctionBody = j(drawRoutesFunction.body);
        drawRoutesFunctionBody.find(j.ExpressionStatement, {
            expression: {
                callee: {
                    object: { name: routerArgName },
                    property: { name: method }
                },
                arguments: [urlPattern, actionPath].concat(args).map((arg) => {
                    return { value: arg };
                })
            }
        }).remove();
        fs.writeFileSync(routesFilepath, ast.toSource());
    }
    /**
     * Add a package to this project, using yarn or npm as appropriate.
     */
    installPackage(pkgName, dev) {
        debug(`installing ${pkgName}`);
        if (this.shouldUseYarn()) {
            child_process_1.execSync(`yarn add ${dev ? '--dev' : ''} ${pkgName}`);
        }
        else {
            child_process_1.execSync(`npm install ${dev ? '-D' : '-S'} ${pkgName}`);
        }
    }
    /**
     * Add multiple packages to this project, using yarn or npm as appropriate.
     */
    installPackages(pkgNames, dev) {
        debug(`installing ${pkgNames.join(', ')}`);
        if (this.shouldUseYarn()) {
            child_process_1.execSync(`yarn add ${dev ? '--dev' : ''} ${pkgNames.join(' ')}`);
        }
        else {
            child_process_1.execSync(`npm install ${dev ? '-D' : '-S'} ${pkgNames.join(' ')}`);
        }
    }
    /**
     * Remove a package from this project, using yarn or npm as appropriate.
     */
    uninstallPackage(pkgName) {
        debug(`uninstalling ${pkgName}`);
        if (this.shouldUseYarn()) {
            child_process_1.execSync(`yarn remove ${pkgName}`);
        }
        else {
            child_process_1.execSync(`npm uninstall -S ${pkgName}`);
        }
    }
    /**
     * Remove multiple packages from this project, using yarn or npm as appropriate.
     */
    uninstallPackages(pkgNames) {
        debug(`uninstalling ${pkgNames.join(', ')}`);
        if (this.shouldUseYarn()) {
            child_process_1.execSync(`yarn remove ${pkgNames.join(' ')}`);
        }
        else {
            child_process_1.execSync(`npm uninstall -S ${pkgNames.join(' ')}`);
        }
    }
    /**
     * Check to see whether this project is using yarn for package management
     */
    shouldUseYarn() {
        return command_exists_1.sync('yarn') && fs.existsSync('yarn.lock');
    }
}
/**
 * Files that should be renamed in all blueprints
 * Can be overriden/extended by individual addons
 */
Blueprint.renamedFiles = {
    gitignore: '.gitignore'
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Blueprint;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmx1ZXByaW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2JsdWVwcmludC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG1DQVFnQjtBQUNoQiw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLGlEQUFnRDtBQUNoRCxtREFBdUQ7QUFDdkQsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQixrQ0FBa0M7QUFDbEMseUNBQXlDO0FBQ3pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFHakMsK0NBQW1EO0FBR25ELDZCQUFzQjtBQUN0QiwrQ0FBdUM7QUFDdkMsdUNBQWdDO0FBRWhDLHFDQUFxQztBQUNyQywwQ0FBMEM7QUFFMUMsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFFbEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFDSCxlQUErQixTQUFRLGlCQUFPO0lBRTVDOztPQUVHO0lBQ0ksTUFBTSxDQUFDLDBCQUEwQixDQUFDLEtBQWlCLEVBQUUsTUFBOEIsRUFBRSxVQUFlO1FBQ3pHLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDakQsTUFBTSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsY0FBYyxDQUFDLFVBQWU7UUFDMUMsSUFBSSxVQUFVLEdBQXlDLEVBQUUsQ0FBQztRQUMxRCxnRkFBZ0Y7UUFDaEYsSUFBSSxNQUFNLEdBQUcscUJBQVUsQ0FBQyxVQUFVLElBQUksVUFBVSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsQ0FBQztRQUNwRSxLQUFLLENBQUMsMkNBQTRDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FB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QUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzdELENBQUM7O0FBM1NEOzs7R0FHRztBQUNXLHNCQUFZLEdBQVE7SUFDOUIsU0FBUyxFQUFFLFlBQVk7Q0FDMUIsQ0FBQzs7QUF6R0osNEJBaVpDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgdGVtcGxhdGUsXG4gIGZvckVhY2gsXG4gIG1lcmdlLFxuICBhc3NpZ24sXG4gIGludGVyc2VjdGlvbixcbiAgbWFwS2V5cyxcbiAga2V5c1xufSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IGV4ZWNTeW5jIGFzIHJ1biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc3luYyBhcyBjb21tYW5kRXhpc3RzIH0gZnJvbSAnY29tbWFuZC1leGlzdHMnO1xuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgKiBhcyB3YWxrIGZyb20gJ3dhbGstc3luYyc7XG5pbXBvcnQgKiBhcyBjb2Rlc2hpZnQgZnJvbSAnanNjb2Rlc2hpZnQnO1xuaW1wb3J0ICogYXMgbWtkaXJwIGZyb20gJ21rZGlycCc7XG5pbXBvcnQgKiBhcyByaW1yYWYgZnJvbSAncmltcmFmJztcbmltcG9ydCAqIGFzIHlhcmdzIGZyb20gJ3lhcmdzJztcbmltcG9ydCByZXF1aXJlVHJlZSA9IHJlcXVpcmUoJ3JlcXVpcmUtdHJlZScpO1xuaW1wb3J0IHsgc3luYyBhcyBpc0RpcmVjdG9yeSB9IGZyb20gJ2lzLWRpcmVjdG9yeSc7XG5pbXBvcnQgUHJvamVjdCBmcm9tICcuL3Byb2plY3QnO1xuaW1wb3J0IHsgT3B0aW9ucyBhcyBZYXJnc09wdGlvbnMgfSBmcm9tICd5YXJncyc7XG5pbXBvcnQgdWkgZnJvbSAnLi91aSc7XG5pbXBvcnQgZmluZEFkZG9ucyBmcm9tICcuL2ZpbmQtYWRkb25zJztcbmltcG9ydCBDb21tYW5kIGZyb20gJy4vY29tbWFuZCc7XG5pbXBvcnQgKiBhcyBhcmdQYXJzZXIgZnJvbSAneWFyZ3MnO1xuaW1wb3J0ICogYXMgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0ICogYXMgdHJ5UmVxdWlyZSBmcm9tICd0cnktcmVxdWlyZSc7XG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ2RlbmFsaS1jbGk6Ymx1ZXByaW50Jyk7XG5cbi8qKlxuICogVGhlIEJsdWVwcmludCBjbGFzcyBtYW5hZ2VzIGdlbmVyYXRpbmcgY29kZSBmcm9tIGEgdGVtcGxhdGUsIG9yIFwiYmx1ZXByaW50XCIuIEJsdWVwcmludHMgaGF2ZVxuICogdGhyZWUgbWFpbiBwYXJ0czpcbiAqXG4gKiAtIFRoZSBgbG9jYWxzKClgIGhvb2ssIHVzZWQgdG8gZ2VuZXJhdGUgZGF0YSB0byBmaWxsIGluIHRoZSB0aGUgdGVtcGxhdGVzXG4gKlxuICogLSBUZW1wbGF0ZXMsIGZvdW5kIHVuZGVyIGA8Ymx1ZXByaW50IGRpcj4vZmlsZXNgLiBUaGVzZSBmaWxlcyBhcmUgY29waWVkIG92ZXIgaW50byB0aGUgcHJvamVjdC5cbiAqICAgVGhlIGNhbiBjb250YWluIEVSQiBzdHlsZSBpbnRlcnBvbGF0aW9uIHRvIGluamVjdCB2YWx1ZXMgZnJvbSB0aGUgYGxvY2Fsc2AgZGF0YS4gRmlsZW5hbWVzIGNhblxuICogICBhbHNvIGNvbnRhaW4gdmFyaWFibGVzLCBkZWxpbWl0ZWQgYnkgYF9fdmFyaWFibGVfX2BcbiAqXG4gKiAtIFRoZSBgcG9zdEluc3RhbGwoKWAgaG9vaywgd2hpY2ggcnVucyBhZnRlciB0aGUgY29weWluZyBvcGVyYXRpb24gaXMgZmluaXNoZWQuIFRoaXMgZ2l2ZXMgdGhlXG4gKiAgIGJsdWVwcmludCBhIGNoYW5jZSB0byBwZXJmb3JtIGFkZGl0aW9uYWwgc3RlcHMgdGhhdCBzaW1wbGUgdGVtcGxhdGluZyBjYW4ndCBzdXBwb3J0IChpLmUuXG4gKiAgIGluc3RhbGwgYW4gbm9kZSBtb2R1bGUpLlxuICpcbiAqIFRoZSBjb2RlIGdlbmVyYXRlZCBieSBhIGJsdWVwcmludCBjYW4gYWxzbyBiZSByZW1vdmVkIHZpYSB0aGUgYGRlc3Ryb3lgIGNvbW1hbmQuIFRoYXQgY29tbWFuZFxuICogd2lsbCBvbmx5IHJlbW92ZSBmaWxlcyB0aGF0IGV4YWN0bHkgbWF0Y2ggdGhlIHdoYXQgdGhlIGJsdWVwcmludCBnZW5lcmF0ZXMsIHNvIGlmIHlvdSBtb2RpZnkgYVxuICogZmlsZSBhZnRlciBpdCB3YXMgZ2VuZXJhdGVkLCBpdCB3b24ndCBiZSByZW1vdmVkLlxuICpcbiAqIEBtb2R1bGUgZGVuYWxpLWNsaVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbHVlcHJpbnQgZXh0ZW5kcyBDb21tYW5kIHtcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjYWxsaW5nIGAuZmluZEJsdWVwcmludHMoKWAgYW5kIHRoZW4gYC5jb25maWd1cmVCbHVlcHJpbnRzKClgXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZpbmRBbmRDb25maWd1cmVCbHVlcHJpbnRzKHlhcmdzOiB5YXJncy5Bcmd2LCBhY3Rpb246ICdnZW5lcmF0ZScgfCAnZGVzdHJveScsIHByb2plY3RQa2c6IGFueSkge1xuICAgIGxldCBibHVlcHJpbnRzID0gdGhpcy5maW5kQmx1ZXByaW50cyhwcm9qZWN0UGtnKTtcbiAgICByZXR1cm4gdGhpcy5jb25maWd1cmVCbHVlcHJpbnRzKGJsdWVwcmludHMsIHlhcmdzLCBhY3Rpb24sIHByb2plY3RQa2cpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIGF2YWlsYWJsZSBibHVlcHJpbnRzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZpbmRCbHVlcHJpbnRzKHByb2plY3RQa2c6IGFueSkge1xuICAgIGxldCBibHVlcHJpbnRzOiB7IFtuYW1lOiBzdHJpbmddOiB0eXBlb2YgQmx1ZXByaW50IH0gPSB7fTtcbiAgICAvLyBTcGVjaWFsIGNhc2UgZGVuYWxpIGl0c2VsZiwgc28gaXQgY2FuIGFjY2VzcyBpdCdzIGdsb2JhbGx5IGxpbmtlZCBibHVlcHJpbnRzLlxuICAgIGxldCBhZGRvbnMgPSBmaW5kQWRkb25zKHByb2plY3RQa2cgJiYgcHJvamVjdFBrZy5uYW1lICE9PSAnZGVuYWxpJyk7XG4gICAgZGVidWcoYGRpc2NvdmVyaW5nIGF2YWlsYWJsZSBibHVlcHJpbnRzIGZyb20gWyAkeyBhZGRvbnMubWFwKChhKSA9PiBhLnBrZy5uYW1lKS5qb2luKCcsICcpIH0gXSBhZGRvbnNgKTtcbiAgICBhZGRvbnMuZm9yRWFjaCgoYWRkb24pID0+IHtcbiAgICAgIHRoaXMuZGlzY292ZXJCbHVlcHJpbnRzRm9yQWRkb24oYmx1ZXByaW50cywgYWRkb24ucGtnLm5hbWUsIHBhdGguam9pbihhZGRvbi5kaXIsICdibHVlcHJpbnRzJykpO1xuICAgIH0pO1xuICAgIHJldHVybiBibHVlcHJpbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgc2V0IG9mIGJsdWVwcmludHMgYW5kIGEgeWFyZ3MgaW5zdGFuY2UsIGdpdmVuIGVhY2ggYmx1ZXByaW50IHRoZSBjaGFuY2UgdG8gYWRkIGFcbiAgICogY29tbWFuZCB0byB0aGUgeWFyZ3MgaW5zdGFuY2UgZm9yIGl0c2VsZlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjb25maWd1cmVCbHVlcHJpbnRzKGJsdWVwcmludHM6IHsgW25hbWU6IHN0cmluZ106IHR5cGVvZiBCbHVlcHJpbnQgfSwgeWFyZ3M6IHlhcmdzLkFyZ3YsIGFjdGlvbjogJ2dlbmVyYXRlJyB8ICdkZXN0cm95JywgcHJvamVjdFBrZzogYW55KSB7XG4gICAgLy8gQ29uZmlndXJlIGEgeWFyZ3MgaW5zdGFuY2Ugd2l0aCBhIGNvbW1hbmQgZm9yIGVhY2ggb25lXG4gICAgZm9yRWFjaChibHVlcHJpbnRzLCAoQmx1ZXByaW50Q2xhc3M6IHR5cGVvZiBCbHVlcHJpbnQsIG5hbWU6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVidWcoYGNvbmZpZ3VyaW5nICR7IEJsdWVwcmludENsYXNzLmJsdWVwcmludE5hbWUgfSBibHVlcHJpbnQgKGludm9jYXRpb246IFwiJHsgbmFtZSB9XCIpYCk7XG4gICAgICAgIHlhcmdzID0gQmx1ZXByaW50Q2xhc3MuY29uZmlndXJlKG5hbWUsIHlhcmdzLCBwcm9qZWN0UGtnLCBhY3Rpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdWkud2FybihgJHsgbmFtZSB9IGJsdWVwcmludCBmYWlsZWQgdG8gY29uZmlndXJlIGl0c2VsZjpgKTtcbiAgICAgICAgdWkud2FybihlcnJvci5zdGFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHlhcmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIGFkZG9uJ3MgbmFtZSBhbmQgc291cmNlIGRpcmVjdG9yeSwgbG9hZCBhbGwgdGhlIGJsdWVwcmludHMgdGhhdCBhZGRvbiBtYXkgc3VwcGx5XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGRpc2NvdmVyQmx1ZXByaW50c0ZvckFkZG9uKGJsdWVwcmludHNTb0ZhcjogeyBbYmx1ZXByaW50TmFtZTogc3RyaW5nXTogdHlwZW9mIEJsdWVwcmludCB9LCBhZGRvbk5hbWU6IHN0cmluZywgZGlyOiBzdHJpbmcpIHtcbiAgICBkZWJ1ZyhgbG9va2luZyBmb3IgYmx1ZXByaW50cyBpbiAkeyBkaXIgfWApO1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgICBkZWJ1ZyhgJHsgZGlyIH0gZG9lcyBub3QgZXhpc3QsIHNraXBwaW5nIC4uLmApO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvLyBMb2FkIHRoZSBibHVlcHJpbnRzXG4gICAgbGV0IEJsdWVwcmludHMgPSBmcy5yZWFkZGlyU3luYyhkaXIpXG4gICAgICAuZmlsdGVyKChkaXJuYW1lKSA9PiBpc0RpcmVjdG9yeShwYXRoLmpvaW4oZGlyLCBkaXJuYW1lKSkpXG4gICAgICAucmVkdWNlPHsgW2tleTogc3RyaW5nXTogdHlwZW9mIEJsdWVwcmludCB9PigoQmx1ZXByaW50c1NvRmFyLCBkaXJuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IEJsdWVwcmludENsYXNzID0gdHJ5UmVxdWlyZShwYXRoLmpvaW4oZGlyLCBkaXJuYW1lKSk7XG4gICAgICAgIGFzc2VydChCbHVlcHJpbnRDbGFzcywgYFVuYWJsZSB0byBsb2FkIGJsdWVwcmludCBmcm9tICR7IHBhdGguam9pbihkaXIsIGRpcm5hbWUpIH1gKTtcbiAgICAgICAgQmx1ZXByaW50Q2xhc3MuYWRkb24gPSBhZGRvbk5hbWU7XG4gICAgICAgIEJsdWVwcmludHNTb0ZhcltkaXJuYW1lXSA9IEJsdWVwcmludENsYXNzLmRlZmF1bHQgfHwgQmx1ZXByaW50Q2xhc3M7XG4gICAgICAgIHJldHVybiBCbHVlcHJpbnRzU29GYXI7XG4gICAgICB9LCB7fSk7XG4gICAgLy8gQ2FwdHVyZSB0aGUgc291cmNlIGRpcmVjdG9yeSBvZiB0aGUgYmx1ZXByaW50XG4gICAgZm9yRWFjaChCbHVlcHJpbnRzLCAoQmx1ZXByaW50Q2xhc3MsIGJsdWVwcmludERpcikgPT4ge1xuICAgICAgQmx1ZXByaW50Q2xhc3MuZGlyID0gcGF0aC5qb2luKGRpciwgYmx1ZXByaW50RGlyKTtcbiAgICB9KTtcbiAgICAvLyBUaGVuIHVzZSB0aGUgYmx1ZXByaW50TmFtZSBhcyB0aGUgaW52b2NhdGlvbiBuYW1lLCBpZiBwcm92aWRlZCAob3RoZXJ3aXNlLCBmYWxsYmFjayB0byB0aGVcbiAgICAvLyBkaXJlY3RvcnkgbmFtZVxuICAgIEJsdWVwcmludHMgPSBtYXBLZXlzKEJsdWVwcmludHMsIChCbHVlcHJpbnRDbGFzcywgYmx1ZXByaW50RGlyKSA9PiBCbHVlcHJpbnRDbGFzcy5ibHVlcHJpbnROYW1lIHx8IGJsdWVwcmludERpcik7XG4gICAgZGVidWcoYGZvdW5kICR7IGtleXMoQmx1ZXByaW50cykubGVuZ3RoIH0gYmx1ZXByaW50cyBmb3IgJHsgYWRkb25OYW1lIH06IFsgJHsga2V5cyhCbHVlcHJpbnRzKS5qb2luICgnLCAnKSB9IF1gKTtcbiAgICAvLyBNb3ZlIGFueSBhbHJlYWR5LWxvYWRlZCBibHVlcHJpbnRzIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGVzZSBuZXcgb25lcyB1bmRlciBhbiBhZGRvbi1zY29wZWRcbiAgICAvLyBuYW1lc3BhY2VcbiAgICBpbnRlcnNlY3Rpb24oa2V5cyhCbHVlcHJpbnRzKSwga2V5cyhibHVlcHJpbnRzU29GYXIpKS5mb3JFYWNoKChjb2xsaWRpbmdCbHVlcHJpbnROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGxldCBjbG9iYmVyZWRCbHVlcHJpbnQgPSBibHVlcHJpbnRzU29GYXJbY29sbGlkaW5nQmx1ZXByaW50TmFtZV07XG4gICAgICBibHVlcHJpbnRzU29GYXJbY2xvYmJlcmVkQmx1ZXByaW50LmFkZG9uICsgJzonICsgY29sbGlkaW5nQmx1ZXByaW50TmFtZV0gPSBjbG9iYmVyZWRCbHVlcHJpbnQ7XG4gICAgfSk7XG4gICAgLy8gQWxzbyBjcmVhdGUgYSBtYXAgd2l0aCB0aGUgYmx1ZXByaW50IG5hbWVzIHNjb3BlZCB0byB0aGUgYWRkb24gbmFtZVxuICAgIHJldHVybiBhc3NpZ24oYmx1ZXByaW50c1NvRmFyLCBCbHVlcHJpbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b21pemUgdGhlIHN1YmNvbW1hbmRzIGhlYWRlciB0byBpbmRpY2F0ZSB0aGF0IGl0J3MgYSBsaXN0IG9mIGJsdWVwcmludHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY29uZmlndXJlKGJsdWVwcmludE5hbWU6IHN0cmluZywgeWFyZ3M6IHlhcmdzLkFyZ3YsIHByb2plY3RQa2c6IGFueSwgYWN0aW9uOiAnZ2VuZXJhdGUnIHwgJ2Rlc3Ryb3knKTogeWFyZ3MuQXJndiB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmZpZ3VyZShibHVlcHJpbnROYW1lLCB5YXJncywgcHJvamVjdFBrZywgeyBhY3Rpb24gfSlcbiAgICAgIC51cGRhdGVTdHJpbmdzKHtcbiAgICAgICAgJ0NvbW1hbmRzOic6ICdBdmFpbGFibGUgQmx1ZXByaW50czonXG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSB1c2VkIHRvIGludm9rZSB0aGlzIGJsdWVwcmludC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYmx1ZXByaW50TmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc291cmNlIGRpcmVjdG9yeSBmb3IgdGhpcyBibHVlcHJpbnRzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGRpcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGaWxlcyB0aGF0IHNob3VsZCBiZSByZW5hbWVkIGluIGFsbCBibHVlcHJpbnRzXG4gICAqIENhbiBiZSBvdmVycmlkZW4vZXh0ZW5kZWQgYnkgaW5kaXZpZHVhbCBhZGRvbnNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVuYW1lZEZpbGVzOiBhbnkgPSB7XG4gICAgICBnaXRpZ25vcmU6ICcuZ2l0aWdub3JlJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG91bGQgd2UgZ2VuZXJhdGUgb3IgZGVzdHJveSB0aGlzIGJsdWVwcmludD9cbiAgICovXG4gIHB1YmxpYyBhY3Rpb246ICdnZW5lcmF0ZScgfCAnZGVzdHJveSc7XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IGRlbGVnYXRlcyB0byBlaXRoZXIgZ2VuZXJhdGUgb3IgZGVzdHJveVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJ1bihhcmd2OiBhbnkpIHtcbiAgICBpZiAoYXJndi5hY3Rpb24gPT09ICdnZW5lcmF0ZScpIHtcbiAgICAgIGF3YWl0ICB0aGlzLmdlbmVyYXRlKGFyZ3YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLmRlc3Ryb3koYXJndik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHRoZSBibHVlcHJpbnQuIEdlbmVyYXRlcyB0aGUgZGF0YSB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSB0ZW1wbGF0ZXMsIHRoZW4gY29waWVzIHRoZVxuICAgKiB0ZW1wbGF0ZSBmaWxlcyBvdmVyIGludG8gdGhlIHByb2plY3QuIEZpbmFsbHksIHJ1bnMgdGhlIHBvc3RJbnN0YWxsIGhvb2suXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGUoYXJndjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmxvY2Fscyhhcmd2KTtcbiAgICBsZXQgZGVzdCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgbGV0IHJlbmFtZWRGaWxlcyA9ICg8dHlwZW9mIEJsdWVwcmludD50aGlzLmNvbnN0cnVjdG9yKS5yZW5hbWVkRmlsZXM7XG5cbiAgICB3YWxrKHRoaXMudGVtcGxhdGVGaWxlcykuZm9yRWFjaCgocmVsYXRpdmVwYXRoOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgIGxldCBhYnNvbHV0ZXBhdGggPSBwYXRoLnJlc29sdmUocGF0aC5qb2luKHRoaXMudGVtcGxhdGVGaWxlcywgcmVsYXRpdmVwYXRoKSk7XG4gICAgICBpZiAoaXNEaXJlY3RvcnkoYWJzb2x1dGVwYXRoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbGV0IGZpbGVuYW1lVGVtcGxhdGUgPSB0ZW1wbGF0ZShyZWxhdGl2ZXBhdGgsIHtcbiAgICAgICAgaW50ZXJwb2xhdGU6IC9fXyguKz8pX18vZyxcbiAgICAgICAgc291cmNlVVJMOiByZWxhdGl2ZXBhdGhcbiAgICAgIH0pO1xuICAgICAgbGV0IGRlc3RSZWxhdGl2ZXBhdGggPSBmaWxlbmFtZVRlbXBsYXRlKGRhdGEpO1xuICAgICAgbGV0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShkZXN0UmVsYXRpdmVwYXRoKTtcblxuICAgICAgaWYgKHJlbmFtZWRGaWxlc1tiYXNlbmFtZV0pIHtcbiAgICAgICAgICBkZXN0UmVsYXRpdmVwYXRoID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShkZXN0UmVsYXRpdmVwYXRoKSwgcmVuYW1lZEZpbGVzW2Jhc2VuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBkZXN0QWJzb2x1dGVwYXRoID0gcGF0aC5qb2luKGRlc3QsIGRlc3RSZWxhdGl2ZXBhdGgpO1xuXG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhkZXN0QWJzb2x1dGVwYXRoKSkge1xuICAgICAgICB1aS5pbmZvKGAkeyBjaGFsay5ncmVlbignYWxyZWFkeSBleGlzdHMnKSB9ICR7IGRlc3RSZWxhdGl2ZXBhdGggfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBjb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhhYnNvbHV0ZXBhdGgsICd1dGYtOCcpO1xuICAgICAgbGV0IGNvbnRlbnRzVGVtcGxhdGUgPSB0ZW1wbGF0ZShjb250ZW50cywge1xuICAgICAgICBpbnRlcnBvbGF0ZTogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgICAgIHNvdXJjZVVSTDogcmVsYXRpdmVwYXRoXG4gICAgICB9KTtcbiAgICAgIG1rZGlycC5zeW5jKHBhdGguZGlybmFtZShkZXN0QWJzb2x1dGVwYXRoKSk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGRlc3RBYnNvbHV0ZXBhdGgsIGNvbnRlbnRzVGVtcGxhdGUoZGF0YSkpO1xuICAgICAgdWkuaW5mbyhgJHsgY2hhbGsuZ3JlZW4oJ2NyZWF0ZScpIH0gJHsgZGVzdFJlbGF0aXZlcGF0aCB9YCk7XG4gICAgfSk7XG5cbiAgICBpZiAoIWFyZ3Yuc2tpcFBvc3RJbnN0YWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnBvc3RJbnN0YWxsKGFyZ3YpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB1aS5lcnJvcigncG9zdEluc3RhbGwgZmFpbGVkOicpO1xuICAgICAgICB1aS5lcnJvcihlLnN0YWNrIHx8IGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBibHVlcHJpbnQuIEdlbmVyYXRlcyB0aGUgZGF0YSB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSB0ZW1wbGF0ZXMsIHRoZW4gZGVsZXRlcyBhbnlcbiAgICogdW5tb2RpZmllZCBmaWxlcyB0aGF0IHdlcmUgZ2VuZXJhdGVkIGJ5IHRoaXMgYmx1ZXByaW50LiBUaGVuIHJ1bnMgdGhlIHBvc3RVbmluc3RhbGwgaG9vay5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZXN0cm95KGFyZ3Y6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBkYXRhID0gdGhpcy5sb2NhbHMoYXJndik7XG4gICAgbGV0IGRlc3QgPSBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgbGV0IGZpbGVzVG9EZWxldGU6IHN0cmluZ1tdID0gW107XG4gICAgd2Fsayh0aGlzLnRlbXBsYXRlRmlsZXMpLmZvckVhY2goKHJlbGF0aXZlcGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZXNUb0RlbGV0ZS5wdXNoKHBhdGgucmVzb2x2ZShwYXRoLmpvaW4odGhpcy50ZW1wbGF0ZUZpbGVzLCByZWxhdGl2ZXBhdGgpKSk7XG4gICAgfSk7XG5cbiAgICAvLyBHZXQgdGhlIGFic29sdXRlIHBhdGhzIGZvciB0aGUgdGVtcGxhdGUgc291cmNlIGZpbGUgYW5kIHRoZSBkZXN0IGZpbGVcbiAgICBmaWxlc1RvRGVsZXRlID0gZmlsZXNUb0RlbGV0ZS5tYXAoKGFic29sdXRlcGF0aCkgPT4ge1xuICAgICAgbGV0IHJlbGF0aXZlcGF0aCA9IHBhdGgucmVsYXRpdmUodGhpcy50ZW1wbGF0ZUZpbGVzLCBhYnNvbHV0ZXBhdGgpO1xuICAgICAgbGV0IGZpbGVuYW1lVGVtcGxhdGUgPSB0ZW1wbGF0ZShyZWxhdGl2ZXBhdGgsIHsgaW50ZXJwb2xhdGU6IC9fXyhbXFxTXSspX18vZyB9KTtcbiAgICAgIGxldCBkZXN0UmVsYXRpdmVwYXRoID0gZmlsZW5hbWVUZW1wbGF0ZShkYXRhKTtcbiAgICAgIGxldCBkZXN0QWJzb2x1dGVwYXRoID0gcGF0aC5qb2luKGRlc3QsIGRlc3RSZWxhdGl2ZXBhdGgpO1xuICAgICAgcmV0dXJuIHsgZGVzdEFic29sdXRlcGF0aCwgZGVzdFJlbGF0aXZlcGF0aCwgYWJzb2x1dGVwYXRoIH07XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZGVzdCBmaWxlIGFjdHVhbGx5IGV4aXN0c1xuICAgIH0pLmZpbHRlcigoeyBkZXN0QWJzb2x1dGVwYXRoLCBkZXN0UmVsYXRpdmVwYXRoLCBhYnNvbHV0ZXBhdGggfSkgPT4ge1xuICAgICAgaWYgKGlzRGlyZWN0b3J5KGFic29sdXRlcGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV0IGZpbGVFeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRlc3RBYnNvbHV0ZXBhdGgpO1xuICAgICAgaWYgKCFmaWxlRXhpc3RzKSB7XG4gICAgICAgIHVpLmluZm8oYCR7IGNoYWxrLmdyZXkoJ21pc3NpbmcnKSB9ICR7IGRlc3RSZWxhdGl2ZXBhdGggfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbGVFeGlzdHM7XG5cbiAgICAvLyBBbmQgZWl0aGVyIGhhc24ndCBiZWVuIGFsdGVyZWQsIG9yIHRoZSBmb3JjZSBvcHRpb24gaXMgYmVpbmcgdXNlZCwgdG8gZW5zdXJlIHdlIGRvbid0IGRlc3Ryb3lcbiAgICAvLyBjb2RlXG4gICAgfSkuZmlsdGVyKCh7IGRlc3RBYnNvbHV0ZXBhdGgsIGFic29sdXRlcGF0aCwgZGVzdFJlbGF0aXZlcGF0aCB9KSA9PiB7XG4gICAgICBsZXQgdGVtcGxhdGVTcmMgPSBmcy5yZWFkRmlsZVN5bmMoYWJzb2x1dGVwYXRoLCAndXRmLTgnKTtcbiAgICAgIGxldCBjb21waWxlZCA9IHRlbXBsYXRlKHRlbXBsYXRlU3JjKTtcbiAgICAgIGxldCBkZXN0RmlsZUlzTm90RGlydHkgPSBmcy5yZWFkRmlsZVN5bmMoZGVzdEFic29sdXRlcGF0aCwgJ3V0Zi04JykgPT09IGNvbXBpbGVkKGRhdGEpO1xuXG4gICAgICBpZiAoZGVzdEZpbGVJc05vdERpcnR5KSB7XG4gICAgICAgIHVpLmluZm8oYCR7IGNoYWxrLnJlZCgnZGVzdHJveScpIH0gJHsgZGVzdFJlbGF0aXZlcGF0aCB9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1aS5pbmZvKGAkeyBjaGFsay5ibHVlKCdza2lwcGVkJykgfSAkeyBkZXN0UmVsYXRpdmVwYXRoIH1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc3RGaWxlSXNOb3REaXJ0eTtcbiAgICB9KS5tYXAoKHsgZGVzdEFic29sdXRlcGF0aCB9KSA9PiB7XG4gICAgICByZXR1cm4gZGVzdEFic29sdXRlcGF0aDtcbiAgICB9KTtcblxuICAgIGZpbGVzVG9EZWxldGUuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgcmltcmFmLnN5bmMoZmlsZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIWFyZ3Yuc2tpcFBvc3RVbmluc3RhbGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFVuaW5zdGFsbChhcmd2KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdWkuZXJyb3IoJ3Bvc3RJbnN0YWxsIGZhaWxlZDonKTtcbiAgICAgICAgdWkuZXJyb3IoZS5zdGFjayB8fCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBob29rIHRvIGdlbmVyYXRlIGRhdGEgdG8gYmUgaW50ZXJwb2xhdGVkIGludG8gdGhlIGJsdWVwcmludCdzIHRlbXBsYXRlIGZpbGVzLlxuICAgKi9cbiAgcHVibGljIGxvY2Fscyhhcmd2OiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBhcmd2O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYWZ0ZXIgdGhlIHRlbXBsYXRpbmcgc3RlcCBpcyBjb21wbGV0ZSwgbGV0dGluZyB5b3UgbWFrZSBhZGRpdGlvbmFsIG1vZGlmaWNhdGlvbnMgKGkuZS5cbiAgICogaW5zdGFsbCBhIG5vZGUgbW9kdWxlKS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBwb3N0SW5zdGFsbChhcmd2OiBhbnkpOiBQcm9taXNlPHZvaWQ+IHsgLyogbm9vcCBieSBkZWZhdWx0ICovIH1cblxuICAvKipcbiAgICogUnVucyB3aGVuIGBkZW5hbGkgZGVzdHJveWAgaXMgaW52b2tlZCwgYWZ0ZXIgdGhlIGFwcGxpY2FibGUgdGVtcGxhdGUgZmlsZXMgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAqIFlvdSBzaG91bGQgY2xlYW4gdXAgLyByZXZlcnNlIGFueSBjaGFuZ2VzIG1hZGUgaW4gcG9zdEluc3RhbGwoKSwgYnV0IG9ubHkgaW4gYSB3YXkgdGhhdCBhdm9pZHNcbiAgICogcmVtb3ZpbmcgdXNlciBtb2RpZmljYXRpb25zLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHBvc3RVbmluc3RhbGwoYXJndjogYW55KTogUHJvbWlzZTx2b2lkPiB7IC8qIG5vb3AgYnkgZGVmYXVsdCAqLyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhdGggdG8gdGhpcyBibHVlcHJpbnRzIHRlbXBsYXRlIGZpbGVzIGRpcmVjdG9yeS4gRGVmYXVsdHMgdG8gYGZpbGVzL2AuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRlbXBsYXRlRmlsZXMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKCg8dHlwZW9mIEJsdWVwcmludD50aGlzLmNvbnN0cnVjdG9yKS5kaXIsICdmaWxlcycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSByb3V0ZSB0byB0aGlzIHBhY2thZ2UncyByb3V0ZXIuXG4gICAqL1xuICBwdWJsaWMgYWRkUm91dGUobWV0aG9kOiBzdHJpbmcsIHVybFBhdHRlcm46IHN0cmluZywgYWN0aW9uUGF0aD86IHN0cmluZywgLi4uYXJnczogYW55W10pOiB2b2lkIHtcbiAgICBsZXQgcm91dGVzRmlsZXBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2NvbmZpZycsICdyb3V0ZXMuanMnKTtcbiAgICBsZXQgcm91dGVzU291cmNlO1xuICAgIHRyeSB7XG4gICAgICByb3V0ZXNTb3VyY2UgPSBmcy5yZWFkRmlsZVN5bmMocm91dGVzRmlsZXBhdGgsICd1dGYtOCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHVpLndhcm4oYEF0dGVtcHRlZCB0byBhZGQgXCIkeyBtZXRob2QudG9VcHBlckNhc2UoKSB9ICR7IHVybFBhdHRlcm4gfSAtPiAkeyBhY3Rpb25QYXRoIH1cIiByb3V0ZSwgYnV0IGNvbmZpZy9yb3V0ZXMuanMgZG9lcyBub3QgZXhpc3QuIFNraXBwaW5nIC4uLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgaiA9IGNvZGVzaGlmdDtcbiAgICBsZXQgYXN0ID0gY29kZXNoaWZ0KHJvdXRlc1NvdXJjZSk7XG4gICAgbGV0IGRyYXdSb3V0ZXNGdW5jdGlvbiA9IGFzdC5maW5kKGouRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKS5nZXQoKS52YWx1ZS5kZWNsYXJhdGlvbjtcbiAgICBsZXQgcm91dGVyQXJnTmFtZSA9IGRyYXdSb3V0ZXNGdW5jdGlvbi5wYXJhbXNbMF0ubmFtZTtcbiAgICBsZXQgZHJhd1JvdXRlc0Z1bmN0aW9uQm9keSA9IGooZHJhd1JvdXRlc0Z1bmN0aW9uLmJvZHkpO1xuICAgIGxldCBkdXBsaWNhdGUgPSBkcmF3Um91dGVzRnVuY3Rpb25Cb2R5LmZpbmQoai5FeHByZXNzaW9uU3RhdGVtZW50LCB7XG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGNhbGxlZToge1xuICAgICAgICAgIG9iamVjdDogeyBuYW1lOiByb3V0ZXJBcmdOYW1lIH0sXG4gICAgICAgICAgcHJvcGVydHk6IHsgbmFtZTogbWV0aG9kIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXJndW1lbnRzOiBbIHVybFBhdHRlcm4sIGFjdGlvblBhdGggXS5jb25jYXQoYXJncykubWFwKChhcmcpID0+IHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogYXJnIH07XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGR1cGxpY2F0ZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByb3V0ZXJJbnZvY2F0aW9ucyA9IGRyYXdSb3V0ZXNGdW5jdGlvbkJvZHkuZmluZChqLkV4cHJlc3Npb25TdGF0ZW1lbnQsIHtcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgY2FsbGVlOiB7XG4gICAgICAgICAgb2JqZWN0OiB7IG5hbWU6IHJvdXRlckFyZ05hbWUgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGxhc3RSb3V0ZXJJbnZvY2F0aW9uID0gcm91dGVySW52b2NhdGlvbnMuYXQocm91dGVySW52b2NhdGlvbnMubGVuZ3RoIC0gMSk7XG4gICAgbGV0IHJvdXRlck1ldGhvZEV4cHJlc3Npb24gPSBqLm1lbWJlckV4cHJlc3Npb24oai5pZGVudGlmaWVyKHJvdXRlckFyZ05hbWUpLCBqLmlkZW50aWZpZXIobWV0aG9kKSk7XG4gICAgbGV0IHJvdXRlckFyZ3VtZW50cyA9IGFyZ3MubWFwKChhcmcpID0+IGouc3RyaW5nTGl0ZXJhbChhcmcpKTtcbiAgICBsZXQgcm91dGVyTWV0aG9kSW52b2NhdGlvbiA9IGouY2FsbEV4cHJlc3Npb24ocm91dGVyTWV0aG9kRXhwcmVzc2lvbiwgcm91dGVyQXJndW1lbnRzKTtcbiAgICBsZXQgbmV3Um91dGUgPSBqLmV4cHJlc3Npb25TdGF0ZW1lbnQocm91dGVyTWV0aG9kSW52b2NhdGlvbik7XG4gICAgbGFzdFJvdXRlckludm9jYXRpb24uaW5zZXJ0QWZ0ZXIobmV3Um91dGUpO1xuICAgIGZzLndyaXRlRmlsZVN5bmMocm91dGVzRmlsZXBhdGgsIGFzdC50b1NvdXJjZSh7IHF1b3RlOiAnc2luZ2xlJyB9KSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHJvdXRlIGZyb20gdGhpcyBwYWNrYWdlJ3Mgcm91dGVyXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlUm91dGUobWV0aG9kOiBzdHJpbmcsIHVybFBhdHRlcm46IHN0cmluZywgYWN0aW9uUGF0aD86IHN0cmluZywgLi4uYXJnczogYW55W10pOiB2b2lkIHtcbiAgICBsZXQgcm91dGVzRmlsZXBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2NvbmZpZycsICdyb3V0ZXMuanMnKTtcbiAgICBsZXQgcm91dGVzU291cmNlO1xuICAgIHRyeSB7XG4gICAgICByb3V0ZXNTb3VyY2UgPSBmcy5yZWFkRmlsZVN5bmMocm91dGVzRmlsZXBhdGgsICd1dGYtOCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHVpLndhcm4oYEF0dGVtcHRlZCB0byByZW1vdmUgXCIkeyBtZXRob2QudG9VcHBlckNhc2UoKSB9ICR7IHVybFBhdHRlcm4gfSAtPiAkeyBhY3Rpb25QYXRoIH1cIiByb3V0ZSwgYnV0IGNvbmZpZy9yb3V0ZXMuanMgZG9lcyBub3QgZXhpc3QuIFNraXBwaW5nIC4uLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgaiA9IGNvZGVzaGlmdDtcbiAgICBsZXQgYXN0ID0gY29kZXNoaWZ0KHJvdXRlc1NvdXJjZSk7XG4gICAgbGV0IGRyYXdSb3V0ZXNGdW5jdGlvbiA9IGFzdC5maW5kKGouRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKS5nZXQoKS52YWx1ZS5kZWNsYXJhdGlvbjtcbiAgICBsZXQgcm91dGVyQXJnTmFtZSA9IGRyYXdSb3V0ZXNGdW5jdGlvbi5wYXJhbXNbMF0ubmFtZTtcbiAgICBsZXQgZHJhd1JvdXRlc0Z1bmN0aW9uQm9keSA9IGooZHJhd1JvdXRlc0Z1bmN0aW9uLmJvZHkpO1xuICAgIGRyYXdSb3V0ZXNGdW5jdGlvbkJvZHkuZmluZChqLkV4cHJlc3Npb25TdGF0ZW1lbnQsIHtcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgY2FsbGVlOiB7XG4gICAgICAgICAgb2JqZWN0OiB7IG5hbWU6IHJvdXRlckFyZ05hbWUgfSxcbiAgICAgICAgICBwcm9wZXJ0eTogeyBuYW1lOiBtZXRob2QgfVxuICAgICAgICB9LFxuICAgICAgICBhcmd1bWVudHM6IFsgdXJsUGF0dGVybiwgYWN0aW9uUGF0aCBdLmNvbmNhdChhcmdzKS5tYXAoKGFyZykgPT4ge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBhcmcgfTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KS5yZW1vdmUoKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKHJvdXRlc0ZpbGVwYXRoLCBhc3QudG9Tb3VyY2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcGFja2FnZSB0byB0aGlzIHByb2plY3QsIHVzaW5nIHlhcm4gb3IgbnBtIGFzIGFwcHJvcHJpYXRlLlxuICAgKi9cbiAgcHVibGljIGluc3RhbGxQYWNrYWdlKHBrZ05hbWU6IHN0cmluZywgZGV2PzogYm9vbGVhbik6IHZvaWQge1xuICAgIGRlYnVnKGBpbnN0YWxsaW5nICR7IHBrZ05hbWUgfWApO1xuICAgIGlmICh0aGlzLnNob3VsZFVzZVlhcm4oKSkge1xuICAgICAgcnVuKGB5YXJuIGFkZCAkeyBkZXYgPyAnLS1kZXYnIDogJycgfSAkeyBwa2dOYW1lIH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnVuKGBucG0gaW5zdGFsbCAkeyBkZXYgPyAnLUQnIDogJy1TJyB9ICR7IHBrZ05hbWUgfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbXVsdGlwbGUgcGFja2FnZXMgdG8gdGhpcyBwcm9qZWN0LCB1c2luZyB5YXJuIG9yIG5wbSBhcyBhcHByb3ByaWF0ZS5cbiAgICovXG4gIHB1YmxpYyBpbnN0YWxsUGFja2FnZXMocGtnTmFtZXM6IHN0cmluZ1tdLCBkZXY/OiBib29sZWFuKTogdm9pZCB7XG4gICAgZGVidWcoYGluc3RhbGxpbmcgJHsgcGtnTmFtZXMuam9pbignLCAnKSB9YCk7XG4gICAgaWYgKHRoaXMuc2hvdWxkVXNlWWFybigpKSB7XG4gICAgICBydW4oYHlhcm4gYWRkICR7IGRldiA/ICctLWRldicgOiAnJyB9ICR7IHBrZ05hbWVzLmpvaW4oJyAnKSB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bihgbnBtIGluc3RhbGwgJHsgZGV2ID8gJy1EJyA6ICctUycgfSAkeyBwa2dOYW1lcy5qb2luKCcgJykgfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBwYWNrYWdlIGZyb20gdGhpcyBwcm9qZWN0LCB1c2luZyB5YXJuIG9yIG5wbSBhcyBhcHByb3ByaWF0ZS5cbiAgICovXG4gIHB1YmxpYyB1bmluc3RhbGxQYWNrYWdlKHBrZ05hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGRlYnVnKGB1bmluc3RhbGxpbmcgJHsgcGtnTmFtZSB9YCk7XG4gICAgaWYgKHRoaXMuc2hvdWxkVXNlWWFybigpKSB7XG4gICAgICBydW4oYHlhcm4gcmVtb3ZlICR7IHBrZ05hbWUgfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBydW4oYG5wbSB1bmluc3RhbGwgLVMgJHsgcGtnTmFtZSB9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBtdWx0aXBsZSBwYWNrYWdlcyBmcm9tIHRoaXMgcHJvamVjdCwgdXNpbmcgeWFybiBvciBucG0gYXMgYXBwcm9wcmlhdGUuXG4gICAqL1xuICBwdWJsaWMgdW5pbnN0YWxsUGFja2FnZXMocGtnTmFtZXM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgZGVidWcoYHVuaW5zdGFsbGluZyAkeyBwa2dOYW1lcy5qb2luKCcsICcpIH1gKTtcbiAgICBpZiAodGhpcy5zaG91bGRVc2VZYXJuKCkpIHtcbiAgICAgIHJ1bihgeWFybiByZW1vdmUgJHsgcGtnTmFtZXMuam9pbignICcpIH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnVuKGBucG0gdW5pbnN0YWxsIC1TICR7IHBrZ05hbWVzLmpvaW4oJyAnKSB9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSB3aGV0aGVyIHRoaXMgcHJvamVjdCBpcyB1c2luZyB5YXJuIGZvciBwYWNrYWdlIG1hbmFnZW1lbnRcbiAgICovXG4gIHB1YmxpYyBzaG91bGRVc2VZYXJuKCkge1xuICAgIHJldHVybiBjb21tYW5kRXhpc3RzKCd5YXJuJykgJiYgZnMuZXhpc3RzU3luYygneWFybi5sb2NrJyk7XG4gIH1cblxuXG59XG4iXX0=